实验概述

本次实验中，我们会实现一个名为RTP的可靠传输协议。不同于lab1使用TCP来实现传输功能，我们这次将会使用UDP作为基本的传输API，所以在这次实验中，我们还需要补全分片、滑动窗口、超时重传等功能，才能在UDP的简陋支持下实现一个可靠传输协议。

UDP——最简单的传输层协议

！Linux Man

UDP的使用准备和TCP差不多。如果你并不清楚该如何使用UDP相关的函数来完成传输，请在命令行分别输入如下命令：

```bash
man sendto
man recvfrom
```

来查看如何使用这些API。不只是C/C++，部分其他语言和linux shell的命令也支持通过man xxx的方式来查阅如何使用。在以后的工作和学习中，你也可以用这种方式来学习某个命令/API的使用。

？RTFM：为什么要查阅手册，这里明明只需要几行，不能直接给我代码吗？为什么不能上网查呢？

未来在工作和科研中，大家会接触到许多他人已经写好的代码，其中往往会使用一些同学们可能没有见到过的库函数（例如：strtok，或者其他需要另外安装的库），又或者在初次实现某些功能时，会在博客和开源项目中看到一些没见过的函数，但你又不懂如何使用它。这种情况下，比起等待大神的回复，一行man xxx显然更快。所以，学会自己阅读手册是非常重要的。上网查询的好处在于中文博客没有阅读障碍，但是那毕竟不是原版的手册，而手册是会随着库的版本更新的。如果版本不能匹配，或者因为低质量博客引入了错误的代码，那就得不偿失了。

RTP协议头描述

在开始写代码之前，我们还需要介绍一下RTP的协议头结构：

``` cpp
typedef struct RTP_Header {
    uint8_t type;
    uint16_t length;
    uint32_t seq_num;
    uint32_t checksum;
} rtp_header_t;
```

为了简化操作，RTP头里的所有字段的字节序均是小端法

**type**: 标识了一个RTP报文的类型，0:`START`, 1:`END`, 2:`DATA`, 3:`ACK`，如何使用这些类型请参照后续对lab任务的详细描述

**length**: 标识了一个RTP报文**数据段**的长度（即RTP头后的报文长度），对于`START`,`END`,`ACK`类型的报文来说，长度为0

**seq_num**: 序列号，用于识别顺序做按序送达。每一个报文持有的seq_num指明这个报文在整条消息中的次序。例如seq_num为0的报文就是第一个报文

**checksum**: 为RTP头以及RTP报文数据段基于32-bit CRC计算出的值，该计算的API已经在xxx文件中提供。

？RTFSC：这个字段在干啥？这个API有啥用？
如果你并不清楚这个字段的作用，请上网查找或者翻阅课件，这将直接决定你能否正确的使用我们的提供的API。如果你不清楚这个API究竟做了什么，请直接阅读它的源代码，想想为什么它返回的结果可以作为checksum

综上所述，RTP头共计有11个字节，相比之下UDP头有8字节，IP头有20字节。一般在实际的网络中，允许的最大包尺寸不会超过1500字节，如果超过，这些大包会在发送端IP层发出时被自动分片，并在接收端IP层被收取时自动聚合，在传输规模比较大的时候，这些IP层的分片/聚合会带来显著的性能损失。更严重的是，一些网络协议会默认/要求应用层会自己做好分片工作，如果不分片就会让这类协议崩溃。所以我们在发送UDP报文时，需要提前对传输的数据进行分片，根据上述字节数不难得出，我们每个RTP包要携带的数据最多有1500-11-8-20=1461字节

RTP协议的工作流程

**建立连接** `sender`首先发送一个`type`为`START`，并且`seq_num`为随机值的报文，此后`receiver`应该将带有相同`seq_num`的`ACK`报文发回，`sender`收到`ACK`报文并确认`seq_num`正确后，即认为连接已经建立

**数据传输** 在完成连接的建立之后，要发送的数据由`DATA`类型的报文进行传输。发送方的数据报文的`seq_num`从0开始每个报文递增。注意，数据传输阶段使用的`seq_num`与建立连接时使用的`seq_num`没有联系

**终止连接** 在数据传输完毕后，`sender`发送一个`type`为`END`的报文以终止连接。为了保证所有数据都传输完成，该`END`报文的`seq_num`应当和`receiver`期望收到的下一个报文的`seq_num`相同，在接收到由`receiver`发回的带有相同`seq_num`的`ACK`报文后即认为连接断开

！KISS法则：先完成，再完美

在往年的lab中，总有同学希望一次性写完全部的代码，然后再慢慢debug。但是在面对一些大型项目时，这种做法很容易一口气引入大量的bug，让测试过程变得苦不堪言。KISS的意思是：Keep It Simple and Stupid。在实现复杂逻辑的时候，先从最基本的功能开始搭建，然后立马测试，保证这部分代码正确后，再去实现下一批功能。lab2的代码量或许不大，但它要实现的逻辑比较复杂，按照KISS法则步步为营的推进，可以大大提高开发的效率。

第一部分：实现RTP Sender

## 功能说明
`sender`应该读取指定的文件，采用RTP协议，通过UDP套接字将其发送到指定的接收方。

首先，sender需要按照给定的窗口大小和socket地址，对整个模块进行初始化，并按照如下流程和receiver建立连接：

sender发送START报文，其seq_num为随机值

receiver返回ACK报文，其seq_num与sender发出的START中的seq_num一致

sender检查receiver发回的报文，如果无误则认为连接建立

在连接成功建立后，sender需要根据传入的文件名，将其打开、分片并装入不同的包中。在发送之前，请确保包头的每一个字段都被编辑好了

你将会结合滑动窗口的机制来实现可靠传输，窗口大小`window_size`将会作为sender/receiver的初始化参数。你需要保证当前正在传输，并且没有被`receiver`确认的报文数量没有超过`window_size`

？我可以直接把全部的包都发出去，为什么还要用滑动窗口？
当物理网络的性能所向披靡的时候，这显然是最快最方便的做法。但现实的物理网络并不像行为确定的软件那般可靠，如果短时间内突然涌出来大量的包，网络中的交换机会因为无法缓存而不得不丢弃它们。所以一口气发送全部的包反而可能会导致大量的丢包进而导致重传，适得其反。为了保证每个包都被稳稳地送出去，尽量减少重传的次数，这才引入了滑动窗口，来对网络流量进行控制

`sender`在传输完整个文件后，应该发送一个`END`报文以标记连接的终止。注意，这个报文的seq_num依旧符合前述的递增规则，例如最后一个报文的seq_num是1000，那么这个END报文的seq_num就应该是1001

`sender`要保证在如下几种网络情况下可以完成可靠传输:

* sender传出/receiver传回的包丢失
* `ACK`报文的乱序到达
* 任意数量的任意报文多次接收
* `ACK`报文的延迟到达
* receiver传回的报文损坏

每一个`DATA`报文会被一个`ACK`报文所确认，为了处理`DATA`报文丢失或者`ACK`报文丢失的情况，你需要设置一个计时器以自动重传未被确认的`DATA`报文。

该计时器在滑动窗口发生变化时重置，当该计时器到达100ms的时候，需要将**当前窗口中的所有`DATA`报文**全部重新发送

？STFW：我不会写计时器，怎么办？
我们并不强制要求同学们使用某种特定的计时实现，只要你们能够正确的实现100ms的计时即可。当你面对这种你不知道如何实现的功能时，你可以尝试通过搜索引擎查找“C++ 计时”这样的关键词，再结合你看到的博客和linux man，来完成这部分功能，这就是STFW的力量。

## 实现要求

你应当在`sender_def.c`程序中实现以下三个函数，其均已在`sender_def.h`中被声明。

``` cpp
/**
 * @brief 用于建立RTP连接
 * @param receiver_ip receiver的IP地址
 * @param receiver_port receiver的端口
 * @param window_size 滑动窗口大小
 * @return -1表示连接失败，0表示连接成功
 **/
int initSender(const char* receiver_ip, uint16_t receiver_port, uint32_t window_size);

/**
 * @brief 用于发送数据
 * @param message 要发送的文件名
 * @return -1表示发送失败，0表示发送成功
 **/
int sendMessage(const char* message);

/**
 * @brief 用于断开RTP连接以及关闭UDP socket
 **/
void terminateSender();
```

> 实现这三个函数的目的是为了方便进行测试，测试程序会直接调用这三个函数，因此请注意不要使用错误的函数定义。注意，你不需要实现一个完整的`sender`，但如果你希望单独执行它们，你也可以使用这三个函数实现一个自己的`sender`的可执行程序，这并不复杂

> 请不要在函数内部直接使用`exit`等导致**进程**退出的指令，这会导致评测程序也直接停止执行

第二部分：实现RTP Receiver

第三部分：优化RTP Sender/Receiver的重传逻辑

测试你的RTP协议

！基础设施的重要性

lab2的测试涉及随机要素，和你的程序交互的进程将会随机产出一些传输错误，来检查你的传输逻辑是否能够正确的处理这些错误。因此，每一次测试的过程中，你实现的协议的行为都会有一些区别（例如这次丢了第1000个包，但是下一次测试却没丢），这种不确定性将会大大提高debug的难度。这种情况下，为这个项目搭建debug工具将会非常重要。

为了鼓励大家积极使用日志输出来辅助调试，助教团队已经在xxxxx文件提供了一些代码来方便大家为RTP协议增加日志功能：

（一些代码）

作为搭建基础设施一点小小的代价，大家需要为这个函数补齐一部分代码。相信在看到它调用的函数vsprintf之后，结合之前对man的教学，你应该已经很清楚如何完成这部分代码了。
