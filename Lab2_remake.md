# Lab2 RTP

## 前言

lab2的文档中包含一些引导思考（标有 **[?]** ）和提供建议（标有 **[!]** ）的文本，它们提及的问题和任务**不会计入lab2的分数中**。尽管如此，它们还是会为你完成lab2提供或多或少的帮助，请不要遗漏这些内容。

本实验建议的**最大耗时**在20个小时左右，我们相信大部分同学都可以在这个时间内完成实验。如果你在实验的完成过程中**坚持了很久，但感觉遇到了巨大的困难并且束手无策**，请带着你的困扰尽快求助教学团队。

## 郑重声明

教学团队希望培养同学们**自主解决问题的能力**，所以当你产生任何疑问的时候，**请先认真阅读实验文档**，教学团队不负责回答因为不认真阅读文档而产生的问题。

然而，如果同学们发现文档、测评程序和框架代码有**任何不合理或者不清晰的地方**，欢迎带着你们的思考和建议联系助教刘俊宇、曾启桓。

最后，网络课程的查重不是闹着玩的，请大家时刻记住：
**不要抄袭！不要抄袭！不要抄袭！**

## 实验概述

本次实验中，我们会实现一个名为RTP的可靠传输协议。不同于lab1使用TCP来实现传输功能，我们这次将会使用UDP作为基本的传输API。所以在这次实验中，我们还需要补全分片、滑动窗口、超时重传等功能，才能在UDP的简陋支持下实现一个可靠传输协议。

## 背景知识

### RTP协议头描述

首先，我们来了解一下RTP的协议头结构：

``` cpp
typedef struct RTP_Header {
    uint8_t type;
    uint16_t length;
    uint32_t seq_num;
    uint32_t checksum;
} rtp_header_t;
```

为了简化操作，RTP头里的所有字段的字节序均是小端法。

**type** 标识了一个RTP报文的类型，0:`START`, 1:`END`, 2:`DATA`, 3:`ACK`，如何使用这些类型请参照后续对lab任务的详细描述。

**length** 标识了一个RTP报文**数据段**的长度（即RTP头后的payload长度），对于`START`,`END`,`ACK`类型的报文来说，这个字段的值为0。

**seq_num** 序列号，用于识别顺序做按序送达。每一个报文持有的`seq_num`指明这个报文在整条消息中的次序。例如`seq_num`为0的报文就是第一个报文。

**checksum** 为RTP头以及RTP报文数据段基于32-bit CRC计算出的值，该计算的API已经在util.h中提供。

**[?]RTFSC：这个字段在干什么？这个API有什么用？**

> RTFSC的意思是**R**ead **T**he **F**riendly **S**ource **C**ode，许多问题的答案往往就藏在项目的源代码中。如果你并不清楚这个字段的作用，请翻阅课件，这将直接决定你能否正确的使用我们的提供的API。如果你不清楚这个API究竟做了什么，请直接阅读它的源代码，思考为什么它返回的结果可以作为`checksum`。比起被动的灌输知识，我们认为主动的引导同学们思考能更好的提高大家的水平，所以作为RTFSC的练习，我们将`checksum`字段的维护方式以注释形式插入到了我们的CRC源代码中，只要你忠实地阅读了源码，应该就能正确的实现与`checksum`相关的功能。

### UDP编程中需要经常注意的细节

综上所述，RTP头共计有11个字节，相比之下UDP头有8字节，IP头有20字节。一般在实际的网络中，允许的最大报文尺寸不会超过1500字节，如果超过，这些大报文会在发送端IP层发出时被自动分片，并在接收端IP层被收取时自动聚合，在传输规模比较大的时候，这些IP层的分片/聚合会带来显著的性能损失。更严重的是，一些网络协议会默认/要求应用层会自己做好分片工作，如果不分片就会让这类协议崩溃。所以我们在发送UDP报文时，需要提前对传输的数据进行分片。根据上述字节数不难得出，我们每个RTP报文要携带的数据最多有1500-11-8-20=1461字节。

### UDP——最简单的传输层协议

UDP的使用准备和TCP差不多，通过如下流程，即可配置好UDP传输所需的地址信息：

```cpp
sock = socket(AF_INET, SOCK_DGRAM, 0);
bzero(&dstAddr, sizeof(&dstAddr));
dstAddr.sin_family = AF_INET;
inet_pton(AF_INET, receiver_ip, &dstAddr.sin_addr);
dstAddr.sin_port = htons(receiver_port);
```

需要注意的是，UDP不是TCP那样的可靠传输协议，它的传输并不是可靠的，经过UDP传输的数据可能会发生损坏或者丢包。为了检查UDP是否完成了传输，你可以检查它们实际传输的字节数是否和你期望传出/接收的字节数一致。如果你不知道如何检查，或者根本不知道如何使用UDP的接口，请在终端运行如下命令查看UDP接口的使用手册：

```bash
man sendto
man recvfrom
```

**[?]RTFM：为什么要查阅手册，不能直接给我代码吗？为什么不能上网查呢？**

> RTFM的意思是**R**ead **T**he **F**riendly **M**anual，未来在工作和科研中，大家会接触到许多他人已经写好的代码，其中往往会使用一些同学们可能没有见到过的库函数（例如：strtok，vprintf），又或者某些库函数太久不接触，你已经忘记怎么用了/它需要include哪个库。这种情况下，比起等待大神的回复，一行man xxx显然更快。所以，学会自己阅读手册是非常重要的。上网查询的好处在于中文博客没有阅读障碍，但是那毕竟不是和你的环境所匹配的手册，而手册是会随着库的版本改变的。如果版本不能匹配，或者因为低质量博客引入了错误的代码，那就得不偿失了。

## 任务概览

### RTP协议的工作流程

**建立连接** `sender`首先发送一个`type`为`START`，并且`seq_num`为随机值的报文，此后`receiver`应该将带有相同`seq_num`的`ACK`报文发回，`sender`收到`ACK`报文并确认`seq_num`正确后，即认为连接已经建立。

**数据传输** 在完成连接的建立之后，要发送的数据由`DATA`类型的报文进行传输。发送方的数据报文的`seq_num`从0开始每个报文递增。注意，数据传输阶段使用的`seq_num`与建立连接时使用的`seq_num`没有联系。具体的传输细节请看后续具体任务的描述。

**终止连接** 在数据传输完毕后，`sender`发送一个`type`为`END`的报文以终止连接。为了保证所有数据都传输完成，该`END`报文的`seq_num`应当和`receiver`期望收到的下一个报文的`seq_num`相同，在接收到由`receiver`发回的带有相同`seq_num`的`ACK`报文后即认为连接断开。

**[!]KISS法则：先完成，再完美**

> 在往年的lab中，总有同学希望一次性写完全部的代码，然后再慢慢debug。但是在面对一些大型项目时，这种做法很容易一口气引入大量的bug，让测试过程变得苦不堪言。KISS的意思是：**K**eep **I**t **S**imple and **S**tupid。在实现复杂逻辑的时候，先从最基本的功能开始搭建，然后立马测试，保证这部分代码正确后，再去实现下一批功能。lab2的代码量或许不大，但它要实现的逻辑比较复杂，按照KISS法则步步为营地推进，可以大大提高开发的效率。

## 任务细节

### 第一部分：实现RTP Sender

#### Sender实现要求

你应当在`sender_def.c`程序中实现以下三个函数，其均已在`sender_def.h`中被声明。

``` cpp
/**
 * @brief 用于建立RTP连接
 * @param receiver_ip receiver的IP地址
 * @param receiver_port receiver的端口
 * @param window_size 滑动窗口大小
 * @return -1表示连接失败，0表示连接成功
 **/
int initSender(const char* receiver_ip, uint16_t receiver_port, uint32_t window_size);

/**
 * @brief 用于发送数据
 * @param message 要发送的文件名
 * @return -1表示发送失败，0表示发送成功
 **/
int sendMessage(const char* message);

/**
 * @brief 用于断开RTP连接以及关闭UDP socket
 **/
void terminateSender();
```

以函数形式实现lab任务是为了方便进行测试，测试程序会直接调用这三个函数，因此请当心不要使用错误的函数定义。注意，你不需要实现一个完整的`sender`，但如果你希望单独执行它们，你也可以使用这三个函数另外实现一个自己的`sender`的可执行程序，这对于后续的lab2任务也一样。在经过lab0的cmake训练后，这对你应该不是问题。

请不要在 **任何要求你实现的函数（包括后续任务）** 内部直接使用`exit`等导致**进程**退出的指令，这会导致评测程序也直接停止执行，无法给出正确的评分。

#### Sender功能说明

`sender`应该读取指定的文件，采用RTP协议，基于GBN算法，通过UDP套接字将其发送到指定的接收方。

##### Sender对任何收入报文的检查

`sender`需要对收到的报文计算其CRC32的`checksum`，对于`checksum`不对的报文应当直接丢弃。

**[?]为什么要丢弃checksum不对的报文呢？**
> 能问出这个问题，说明你对`checksum`的用途仍然不够了解，快去看看课件吧。

##### Sender建立连接

首先，`sender`需要按照给定的窗口大小和socket地址，对整个模块进行初始化，并按照如下流程和`receiver`建立连接：

> - `sender`发送`START`报文，其`seq_num`为随机值
> - `receiver`返回`ACK`报文，其`seq_num`与`sender`发出的`START`报文中的`seq_num`一致
> - `sender`检查`receiver`发回的报文，如果无误则认为连接建立

##### Sender报文处理

在连接成功建立后，`sender`需要根据传入的文件名，将其打开、分片并装入不同的报文中。在发送之前，请确保RTP协议头的每一个字段都被编辑好了。大家可以自由实现这部分逻辑，但作为参考，我们提供一种可行的报文处理逻辑如下：

> - `sender`打开文件，将未发送的文件字节分配给滑动窗口内的报文，作为其`payload`
> - `sender`为装载好`payload`的报文编辑RTP协议头字段
> - `sender`将编辑好的报文通过UDP发出
> - `sender`尝试一次无阻塞的`ACK`报文接收
> - 如果没有收到，继续循环但先不要考虑重传；如果收到了，`ACK`报文的`seq_num`会指明目前`receiver`未收到报文中最小的`seq_num`，请以此调整待发送的报文/已完成发送的报文的集合

##### Sender滑动窗口

你需要结合滑动窗口的机制来调整待发送的报文/已完成发送的报文的集合。窗口大小`window_size`将会作为`sender`/`receiver`的初始化参数。你需要保证当前正在传输，并且没有被`receiver`确认的报文数量，即滑动窗口的上下限之差没有超过`window_size`。所以，当以下情形发生时，你的滑动窗口应该发生一些变化：

> - `sender`已经发出了一些报文，但这些报文中未被`ACK`确认的报文的数量还没有达到滑动窗口的限制。此时，你的滑动窗口的上限应该增加。
> - `sender`的滑动窗口中，在滑动窗口最左侧（也就是窗口中最早发送的报文所在的那一侧）有一个或连续的多个报文已经被`ACK`确认。此时，你的滑动窗口的下限应该缩小。

**[?]我可以直接把全部的报文都发出去，为什么还要用滑动窗口？**

> 当物理网络的性能所向披靡的时候，这显然是最快最方便的做法。但现实的物理网络并不像行为确定的软件那般可靠，如果短时间内突然涌出来大量的报文，网络中的交换机会因为无法缓存而不得不丢弃它们。所以一口气发送全部的报文反而可能会导致大量的丢包进而导致重传，适得其反。为了保证每个报文都被稳稳地送出去，尽量减少重传的次数，这才引入了滑动窗口，来对网络流量进行控制。

##### Sender超时重传

最后，`sender`要添加超时重传的功能，来保证在如下几种网络情况下可以完成可靠传输:

> - `sender`传出/`receiver`传回的报文丢失
> - `ACK`报文的乱序到达
> - 任意数量的任意`ACK`报文多次接收
> - `receiver`传回的报文`checksum`错误

`receiver`对每一个`DATA`报文，会以发回一个`ACK`报文的方式确认收到。为了处理`DATA`报文丢失或者`ACK`报文丢失的情况，你需要设置一个计时器以自动重传未被确认的`DATA`报文。

该计时器在滑动窗口发生变化时重置，当该计时器距离上次重置的时间过去100ms的时候，需要将**当前窗口中的所有`DATA`报文**全部重新发送。

**[?]STFW：我不会写计时器，怎么办？**

> STFW的意思是**S**earch **T**he **F**riendly **W**eb，我们并不强制要求同学们使用某种特定的计时实现，只要你们能够正确的实现100ms的计时即可。当你面对这种你不知道如何实现的功能时，你可以尝试通过搜索引擎查找“**C++ 计时**”这样的关键词，再结合你看到的博客和linux man，来完成这部分功能。当你缺乏解决问题的方向时，STFW能很好的启发你。由于Epoll的计时实现比较复杂，如果你选择使用Epoll编程，请参考下方的代码实现计时器：

```cpp
// TODO: add some codes here
```

##### Sender终止连接

`sender`在传输完整个文件后，应该发送一个`END`报文以标记连接的终止。注意，这个报文的`seq_num`依旧符合前述的递增规则，例如最后一个`DATA`报文的`seq_num`是1000，那么这个`END`报文的`seq_num`就应该是1001。具体的终止流程如下：

> - `sender`收到了最后一个未确认`DATA`报文的`ACK`，确认所有报文已经成功送达
> - `sender`按照上述要求发送`END`报文
> - `sender`收到该`END`报文的`ACK`报文，其`seq_num`应该和`END`报文一致；或者在发出`END`5秒后没有得到回应，即可认为连接已经关闭

### 第二部分：实现RTP Receiver

#### Receiver实现要求

你应当在`receiver_def.c`程序中实现以下三个函数，其均已在`receiver_def.h`中被声明。

``` cpp
/**
 * @brief 开启receiver并在所有IP的port端口监听等待连接
 * 
 * @param port receiver监听的port
 * @param window_size 滑动窗口大小
 * @return -1表示连接失败，0表示连接成功
 */
int initReceiver(uint16_t port, uint32_t window_size);

/**
 * @brief 用于接收数据并在接收完后断开RTP连接
 * @param filename 用于写入接收数据的文件名
 * @return >0表示接收完成后到数据的字节数 -1表示出现其他错误
 */
int recvMessage(char* filename);

/**
 * @brief 用于接收数据失败时断开RTP连接以及关闭UDP socket
 */
void terminateReceiver();
```

#### Receiver功能说明

`receiver`必须基于GBN算法，能准确并且完整的收到及储存`sender`所发的信息。幸运的是，我们只需要考虑仅存在一个`sender`的情况。

##### Receiver对任何收入包的检查

与`sender`相同，`receiver`需要对收到的报文计算其CRC32的`checksum`，对于`checksum`不对的报文应当直接丢弃。

##### Receiver对START包和END包的响应方式

对于每一个被确认接收的`START`报文或`END`报文，你需要发送一个`ACK`报文，该报文的`seq_num`已在`sender`的实现要求中描述，遂不再赘述。由于`receiver`需要通过写入文件来完成传输，请不要忘记在收到`END`报文时对文件写入进行收尾。

##### Receiver对DATA包的响应方式（GBN）

对于每一个被确认接收的`DATA`报文，`receiver`需要发送一个`ACK`报文，该报文的`seq_num`为当前期望收到的下一个`DATA`报文的`seq_num`。这个期望收到的`DATA`报文是当前未被`Receiver`收到的报文中，`seq_num`最小的报文。

举例来说有如下几种情况(设期望收到的下一个报文`seq_num为N`):

> - 如果当前收到的报文`seq_num大于且不等于N`或者发生了`checksum`错误: 则说明发生了丢包/乱序/传输错误。应该丢弃该报文，并发送一个`seq_num=N`的`ACK`。这就是**Go-Back-N**的具体体现。
> - 如果当前收到的报文`seq_num等于N`: 发送一个`seq_num=M`的`ACK`，这里`M`为`seq_num`最小的还没有被缓存的报文，并将`M`前所有缓存的报文按序写入文件（包括最新收到的报文）。

最终，正确实现GBN的`receiver`应该可以保证在如下故障发生时，仍然可以完成可靠传输：

> - `sender`传出/`receiver`传回的报文丢失
> - `DATA`报文的乱序到达
> - 任意数量的任意`DATA`报文多次接收
> - `sender`传出的报文`checksum`错误

##### Receiver的滑动窗口

与`sender`类似，对于那些`seq_num >= N + window_size`或`seq_num < N`的报文会被直接丢弃，以保证`receiver`的滑动窗口大小不超过`window_size`。在如下情况发生时，`receiver`的滑动窗口应该有所变化：

> - `receiver`收到当前期望收到的报文（`seq_num = N`）时，滑动窗口应该向着可接收带有更大`seq_num`报文的方向移动。

**[?]文档没有写Receiver的超时重传，我是不是可以开摆不管了？**

> 这个世界上不存在十全十美的文档，因此你仍然需要考虑隐藏在字面之下的细节。如果`receiver`完全没有重传机制（也就是每个`ACK`报文最多被传输1次，包括对`START`和`END`的回应），在和`sender`交互时，可能会遇到哪些问题？我们希望同学们结合`sender`的重传机制和终止连接的流程，好好想想这个问题，这能让大家对整个lab有更加深刻的认识。如果你发现了这个问题但不知道怎么解决，请直接参考`sender`在终止连接的过程中所做的一切（包括等待时间）。

### 第三部分：优化RTP Sender/Receiver的重传逻辑

#### OPT-Sender/OPT-Receiver实现要求

你应当在`sender_def.c`和`receiver_def.c`中应当实现以下函数，**注意该函数需要兼容之前写的`initSender,initReceiver`以及`terminateSender,terminateReceiver`函数**。

``` cpp

/**
 * @brief 用于发送数据(优化版本的RTP)
 * @param message 要发送的文件名
 * @return -1表示发送失败，0表示发送成功
 **/
int sendMessageOpt(const char* message);

/**
 * @brief 用于接收数据并在接收完后断开RTP连接(优化版本的RTP)
 * @param filename 用于写入接收数据的文件名
 * @return >0表示接收完成后到数据的字节数 -1表示出现其他错误
 */
int recvMessageOpt(char* filename);
```

#### OPT-Sender/OPT-Receiver功能说明

##### 普通版RTP的性能隐患

在这部分中，我们将对前两部分所写的程序做一些优化。我们之前天衣无缝的RTP还存在什么问题呢？考虑在前面的部分中编写的程序，面对如下窗口大小为3的情况时，将如何工作:

> - `sender`向`receiver`发送了`seq_num`分别为0、1、2的三个包，但`seq_num`为0的包在传输中丢失了。
> - 在这种情况下，`receiver`将返回两个`seq_num`为0的`ACK`报文。这将导致`sender`超时并重传`DATA`报文0、1和2。
> - 然而，由于`receiver`已经接收和缓存`DATA`报文1和2，重传的这两个报文是不必要的。

##### 性能优化：选择重传

为了优化RTP在这种情况下的性能，我们需要保证传输成功的包不会被重传。因此，你需要相应地修改你的`receiver`和`sender`，将其重传逻辑修改为**选择重传**。在这个算法中，`ACK`的含义将会发生变化：其`seq_num`不再表示期望收到的下一个`DATA`报文的`seq_num`，而是表示带有该`seq_num`的`DATA`报文已经被`receiver`收到并缓存。所以你需要做如下改动:

> - 对于`sender`：你需要记录当前滑动窗口内的所有`DATA`报文中，哪些报文收到了对应的**正确**`ACK`，哪些没有。当计时器达到重传时限时，重置计时器，并只重传那些**没有被`ACK`确认的报文**。其滑动窗口仍然需要满足不会超出尺寸上限的原则，并会随着传输成功自行移动。
> - 对于`receiver`：在收到`seq_num`为X的`DATA`报文后，检查**其`checksum`是否正确且`seq_num`是否在滑动窗口内**。如果无误，**缓存**该`DATA`报文，并发回一个`seq_num`同样为X的`ACK`报文，以表明带有该`seq_num`的报文已经被成功接收。如果有误，直接丢弃该`DATA`报文并**不作回应**。其滑动窗口仍然需要满足不会超出尺寸上限的原则，能够筛选出并丢弃不在窗口内的传入报文，并会随着传输成功自行移动。

优化后，在之前的例子中，`sender`仍会等待到超时，但仅重传窗口中未被ACK确认的`DATA`报文0，减少了流量的浪费。

## 测试你的RTP协议

**[!]基础设施的重要性**

> lab2的测试涉及随机要素，和你的程序交互的进程将会随机产出一些传输错误，来检查你的传输逻辑是否能够正确的处理这些错误。因此，每一次测试的过程中，你实现的协议所面对的情形都会有一些区别（例如这次丢了第1000个包，但是下一次测试却没丢），这种不确定性将会大大提高debug的难度。所以，为这个项目搭建基础设施（即测试工具）将会非常重要。
> 相信大家在过去几年中经常使用printf大法来输出程序的行为，这是很好的测试方法。但是在测试完成之后，过多的调试输出反而会导致程序运行缓慢，严重浪费同学们的时间（和课程组的经费）。因此我们不得不一行一行删掉日志输出，或者考虑用宏来开关程序的输出：

```cpp
#ifdef DEBUG
printf("sth for debugging\n");
#endif
```

> 但是这种一口气占据三行的日志代码实在是太蠢了，会把源代码弄得脏兮兮的。有没有什么办法可以在一键开关日志的前提下，实现printf的功能，并让日志源代码看起来干净又卫生呢？
> 为了鼓励大家积极使用日志输出来辅助调试，助教团队已经在util.h中提供了一些代码来方便大家为RTP协议增加日志功能：

```cpp
// util.h
#define DEBUG
#ifdef DEBUG
#define LOG_DEBUG(...) \
    do { \
        fprintf(stderr, "\033[40;31m[DEBUG] \033[0m" __VA_ARGS__); \
        fflush(stderr); \
    } while (0)
#else
#define LOG_DEBUG(...)
#endif
```

> 这个宏的用法和printf一致，但可以被**DEBUG**宏开关其输出。另外，我们的测评程序同样会使用这个宏来进行调试输出。如果你希望对二者进行区分，你可以复制之后自行修改一份宏专供自己的代码使用。如果你不知道如何修改，请STFW或参考同样在util.h中的另外两个类似的宏。

## 测试程序规范说明

### 被传输文件的规范

所有测试文件名长度不超过100个字符，仅包含`a-z`26个字母。

传输的数据大小不超过`100MB`，其字符集合为char类型的中任意字符的并集。

### Sender/Receiver的配置规范

`sender`和`receiver`的窗口大小相同，且不超过`512`。

所有测试点均只有`sender`和`receiver`的一对一传输。

### 可能遭遇的错误类型

测试用的`sender`会产生以下四类传输故障：

> - `DATA`报文丢失
> - `DATA`报文乱序
> - `DATA`报文重复
> - `DATA`报文checksum错误

测试用`receiver`会产生以下四类传输故障：

> - `ACK`报文丢失
> - `ACK`报文乱序
> - `ACK`报文重复
> - `ACK`报文checksum错误

### 测试点内容

Deadline前共有26个测试点，其中有2个测试点无传输故障，分别测试原始版本的RTP协议实现和优化版本的RTP协议实现。

其余24个测试点分为4组，每组6个测试，分别测试优化/非优化版本的`sender`/`receiver`。对于每组故障，6个测试点分别为单独的第1-4类传输故障，少量1-4类传输故障任意混合，以及大量1-4类传输故障任意混合。注意：

> - 任何一类故障均可重复出现。
> - 由于窗口大小设置，这24个测试点均有可能发生自然的报文丢失故障，前两个无传输故障测试点不受影响。

Deadline后新增10个测试点，包含更大窗口，更大数据，以及更高故障概率的测试，除这些变化以外均遵守以上说明。

### 评分标准

每个测试点分数相同。

### 项目文件结构

提供的源代码主要包含以下部分：

> - `third_party`文件夹为googletest源代码，不需要修改。
> - `CMakeLists.txt`为一个可用的CMake模板，实现`sender_def.c`, `receiver_def.c`, `rtp.c`后执行`cmake .`以及`make`即可编译全部代码。`rtp.c`不是必须的，你可以根据实际情况选择性使用这些文件，你也可以修改`CMakeList.txt`以满足自己特定的需求。
> - `src`文件夹下为各函数定义的头文件，以及RTP的包头格式。

### 运行测试

编译全部代码后执行`make test CTEST_OUTPUT_ON_FAILURE=TRUE GTEST_COLOR=TRUE`即可生成本地测试脚本`rtp_test_all`，每个测试点分数相同。

若想测试单独的测试点，可运行如下命令：

```bash
./rtp_test_all --gtest_filter=`测试点名`
```

例如：

```bash
./rtp_test_all --gtest_filter=RTP.RECEIVER_TEST_LOST_DATA
```

如果想直接运行全部测试，请直接运行`./rtp_test_all`

关于每个测试点具体调用的测试文件，请参见test.cpp源码。

## 后记
