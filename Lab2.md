# Lab2 RTP

## 前言

lab2的文档中包含一些引导思考（标有 **[?]** ）和提供建议（标有 **[!]** ）的文本，它们提及的问题和任务**不会计入lab2的分数中**。尽管如此，它们还是会为你完成lab2提供或多或少的帮助，请不要遗漏这些内容。

本实验建议的**最大耗时**在20个小时左右，我们相信大部分同学都可以在这个时间内完成实验。如果你在实验的完成过程中**坚持了很久，但感觉遇到了巨大的困难并且束手无策**，请带着你的困扰尽快求助教学团队。

## 郑重声明

教学团队希望培养同学们**自主解决问题的能力**，所以当你产生任何疑问的时候，**请先认真阅读实验文档**，教学团队不负责回答因为不认真阅读文档而产生的问题。

然而，如果同学们发现文档、测评程序和框架代码有**任何不合理或者不清晰的地方**，欢迎带着你们的思考和建议联系助教刘俊宇、曾启桓。

最后，网络课程的查重不是闹着玩的，请大家时刻记住：**不要抄袭！不要抄袭！不要抄袭！**

## 实验概述

本次实验中，我们会实现一个名为RTP的可靠传输协议。不同于lab1使用TCP来实现传输功能，我们这次将会使用UDP作为基本的传输API。所以在这次实验中，我们还需要补全**分片、滑动窗口、超时重传**等功能，才能在UDP的简陋支持下实现一个可靠传输协议。

## 背景知识

### RTP协议头描述

首先，我们来了解一下RTP的协议头结构，它被定义在rtp.h中：

``` cpp
// rtp.h
typedef struct __attribute__((__packed__)) RTP_header {
    uint32_t seq_num;   // Sequence number
    uint16_t length;    // Length of data, 0 for others
    uint32_t checksum;  // 32-bit CRC
    uint8_t flags;      // refers to specific meaning
} rtp_header_t;
```

为了简化操作，RTP头里的所有字段的字节序均是小端法。

> * **seq_num**：表示一个报文在传输序列中的位置。假设`seq_num`从433开始计算，那么`seq_num`为433的包即为发送的第0个包，`seq_num`为536的包是第103个包。注意，`seq_num`可能不是从零开始的
> * **length**：表示一个报文所携带数据（后称payload）的字节数。对于部分不携带数据的报文来说，这个字段的值为0。
> * **checksum**：基于32-bit CRC算法计算得出的校验码，该算法的API `compute_checksum`的声明在util.h中，定义在util.c中。
> * **flags**：它的高5位均为0，但低3位分别表示该报文的三种状态，这三种状态的用途请参考文档的后续描述。其定义请看rtp.h：

```cpp
// rtp.h
typedef enum RtpHeaderFlag {
    RTP_SYN = 0b0001,
    RTP_ACK = 0b0010,
    RTP_FIN = 0b0100,
} rtp_header_flag_t;
```

**[?]RTFSC：checksum这个字段在干什么？这个API有什么用？**

**TODO：将下面这段话插入到CRC的源代码注释中**：checksum会基于整个报文的内容来进行计算。所以你需要在调用compute_checksum之前，将所有字段和payload设置好，并且保证checksum字段设置为0，再以报文指针和协议头字节数+payload字节数作为参数调用compute_checksum。

> RTFSC的意思是**R**ead **T**he **F**riendly **S**ource **C**ode，许多问题的答案往往就藏在项目的源代码中。如果你并不清楚这个字段的作用，请翻阅课件，这将直接决定你能否正确的使用我们的提供的API。如果你不清楚这个API究竟做了什么，请直接阅读它的源代码，思考为什么它返回的结果可以作为`checksum`。比起被动的灌输知识，我们认为主动的引导同学们思考能更好的提高大家的水平，所以作为RTFSC的练习，**我们将`checksum`字段的维护方式以注释形式插入到了我们的CRC源代码中**，只要你忠实地阅读了源码，应该就能正确的实现与`checksum`相关的功能。

### UDP编程中需要经常注意的细节

综上所述，RTP头共计有11个字节，相比之下UDP头有8字节，IP头有20字节。**一般在实际的网络中，允许的最大报文尺寸不会超过1500字节**，如果超过，这些大报文会在发送端IP层发出时被自动分片，并在接收端IP层被收取时自动聚合，在传输规模比较大的时候，这些IP层的分片/聚合会带来显著的性能损失。更严重的是，一些网络协议会默认/要求应用层会自己做好分片工作，如果不分片就会让这类协议崩溃或者开摆放弃传输。所以我们在发送UDP报文时，需要提前对传输的数据进行分片。根据上述字节数不难得出，我们每个RTP报文要携带的数据最多有1500-11-8-20=1461字节。

### UDP——最简单的传输层协议

UDP的使用准备和TCP差不多，由于大家已经经历过lab1和实践课，我们这里只提供一个**简单的，不能直接运行的示例**：

```cpp
// for sender
sock = socket(AF_INET, SOCK_DGRAM, 0);
bzero(&dstAddr, sizeof(&dstAddr));
dstAddr.sin_family = AF_INET;
inet_pton(AF_INET, receiver_ip, &dstAddr.sin_addr);
dstAddr.sin_port = htons(receiver_port);
// for receiver
recverSock = socket(AF_INET, SOCK_DGRAM, 0);
bzero(&recAddr, sizeof(recAddr));
recAddr.sin_family = AF_INET;
recAddr.sin_addr.s_addr = htonl(INADDR_ANY);
recAddr.sin_port = htons(port);
bind(recverSock, &recAddr, sizeof(recAddr));
```

需要注意的是，**UDP不是TCP那样的可靠传输协议**，它的传输并不是可靠的，经过UDP传输的数据可能会发生损坏或者丢包。为了检查UDP是否完成了传输，你可以检查它们实际传输的字节数是否和你期望传出/接收的字节数一致。如果你不知道如何检查，或者根本不知道如何使用UDP的接口，请在终端运行如下命令查看UDP接口的使用手册：

```bash
man sendto
man recvfrom
```

**[?]RTFM：为什么要查阅手册，不能直接给我代码吗？为什么不能上网查呢？**

> RTFM的意思是**R**ead **T**he **F**riendly **M**anual，未来在工作和科研中，大家会接触到许多他人已经写好的代码，其中往往会使用一些同学们可能没有见到过的库函数（例如：strtok，vprintf），又或者某些库函数太久不接触，**你已经忘记怎么用了/它需要include哪个库**。这种情况下，比起等待大神的回复，一行man xxx显然更快。所以，学会自己阅读手册是非常重要的。上网查询的好处在于中文博客没有阅读障碍，但是那毕竟不是和你的环境所匹配的手册，而手册是会随着库的版本改变的。如果版本不能匹配，或者因为低质量博客引入了错误的代码，那就得不偿失了。

## 任务描述

### RTP协议的工作流程

RTP的工作流程共分为三个阶段，分别是**建立连接、数据传输和终止连接**。为了方便大家理解`sender`和`receiver`如何交互，我们会在本节详细描述建立连接与终止连接的流程，而中间数据传输的部分会在后面的章节深入描述。

**建立连接** 我们参考了TCP的三次握手流程来进行连接建立。首先我们会以同样的窗口最大尺寸`window_size`初始化`sender`和`receiver`。之后，我们将`seq_num`的初始值设为在`[0, window_size-1]`之中的随机数，就可以开始发送报文建立连接了。具体步骤如下：

> * **第一次握手**：`sender`发送一个`seq_num`为上述初始值，且`flags`设置了`SYN`，**不携带任何数据**的报文。
> * **第二次握手**：`receiver`启动之后，会等待5s以收到`sender`发出的`SYN`报文。在收到`sender`发来的上述报文后，你需要发回一个`seq_num`为`sender`发来的报文的`seq_num+1`，且`flags`同时设置了`SYN`和`ACK`，并**不携带任何数据**的报文。
> * **第三次握手**：`sender`在收到来自`receiver`的回应报文后，发回一个`flags`标记了`ACK`，且`seq_num`为收到回应报文的`seq_num`的报文。
> * **差错应对**：对于上述三次握手，我们的`sender`和`receiver`需要**遵循相同的错误处理逻辑**：如果在发出报文后，对端100ms内没有任何回应/收到了一个`checksum`错误的报文，则重传该次握手报文。在任意一个发包阶段进行50次重试/`receiver`启动后等待5s之内什么都没有收到/报文`checksum`正确但内容不符合文档描述时，你应该输出错误原因，并**通过让main函数返回-1而不是使用exit来异常结束进程**。

**[?]STFW：我不会写计时功能，怎么办？**

> STFW的意思是**S**earch **T**he **F**riendly **W**eb，我们并不强制要求同学们使用某种特定的计时实现，只要你们能够正确的实现以毫秒为单位的计时即可。当你面对这种你不知道如何实现的功能时，你可以尝试通过**google/bing**查找“**C++ 计时**”这样的关键词，再结合你看到的博客和linux man，来完成这部分功能。当你缺乏解决问题的方向时，STFW能很好的启发你。由于Epoll的计时实现比较复杂，如果你选择使用Epoll编程，请参考下方的代码实现计时器：

```cpp
// TODO: add some codes here
```

**数据传输** 在完成连接的建立之后，要发送的数据由`flags`为0的报文进行传输。发送方的数据报文的`seq_num`从建立连接所用的`seq_num`开始，每个包的`seq_num+1`，即`seq_num`不一定是从零开始的。具体的传输细节请看后续具体任务的描述。**TODO：详述具体的初始seq_num和递增规则。**

**终止连接** 在数据传输完毕后，我们需要关闭`sender`和`receiver`之间的连接，具体步骤如下：

> * **第一次握手**：`sender`发送一个`flags`标记了`FIN`、`seq_num`为按正常传输的最后一个`seq_num`的报文。
> * **第二次握手**：`receiver`收到该报文后需要发回一个标记了`FIN`和`ACK`，并且`seq_num`相同的报文，`sender`收到该报文后，即认为连接终止。
> * **差错应对**：这里遵循和建立连接相似的策略，唯一的区别是，面对建立连接时需要报告错误的情形，由于传输已经完成，我们仍然可以报告错误，但需要直接默认连接关闭，**通过让main函数返回0而不是使用exit来正常结束进程**。

**[!]KISS法则：先完成，再完美**

> 在往年的lab中，总有同学希望一次性写完全部的代码，然后再慢慢debug。但是在面对一些大型项目时，这种做法很容易一口气引入大量的bug，让测试过程变得苦不堪言。KISS的意思是：**K**eep **I**t **S**imple and **S**tupid。在实现复杂逻辑的时候，先从最基本的功能开始搭建，然后立马测试，保证这部分代码正确后，再去实现下一批功能。lab2的代码量或许不大，但它要实现的逻辑比较复杂，**按照KISS法则步步为营地推进，可以大大提高开发的效率**。

### 第一部分：实现RTP Sender

#### Sender实现要求

首先，为了文档描述方便，我们在此约定：**数据报文指代flags为0的报文，ACK报文指代flags字段仅标记了ACK的报文**

你应当在`sender.c`程序中基于给定的`main`函数实现完整的`sender`功能。启动`sender`所需的参数会通过**命令行参数**按照如下顺序给出：接收端ip地址、接收端端口、待传输文件的路径、窗口最大尺寸和是否启用优化模式。

``` cpp
// sender.c
#include "rtp.h"
#include "util.h"

int main(int argc, char **argv) {
    if (argc != 6) {
        LOG_FATAL("Usage: ./sender [receiver ip] [receiver port] [file path] "
                  "[window size] [Mode]\n");
    }

    LOG_DEBUG("Sender: exiting...\n");

    return 0;
}
```

请不要在 **任何要求你实现的代码（包括后续任务）** 中直接使用`exit`等导致**进程**退出的指令，这会导致评测程序也直接停止执行，无法给出正确的评分。

#### Sender功能说明

`sender`应该读取指定的文件，采用RTP协议，基于GBN算法，通过UDP套接字将其发送到指定的接收方。

##### Sender对任何收入报文的检查

`sender`需要对收到的报文计算其CRC32的`checksum`，对于`checksum`不对的报文应当直接丢弃。

**[?]为什么要丢弃checksum不对的报文呢？**
> 能问出这个问题，说明你对`checksum`的用途仍然不够了解，快去看看课件吧。

##### Sender建立连接与终止连接

首先，`sender`需要按照给定的窗口大小和socket地址，对整个模块进行初始化，并按照前述流程建立连接。在传输结束后，需要按照前述流程终止连接。

##### Sender报文处理

在连接成功建立后，`sender`需要根据传入的文件名，将其打开、分片并装入不同的报文中并发送。在发送之前，请确保RTP协议头的每一个字段都被编辑好了。大家可以自由实现这部分逻辑，但作为参考，我们提供一种可行的报文处理逻辑如下：

**TODO：检查这个逻辑是否可用**

> * `sender`打开文件，将未发送的文件字节分配给滑动窗口内的报文，作为其`payload`
> * `sender`为装载好`payload`的报文编辑RTP协议头字段
> * `sender`将编辑好的报文通过UDP发出
> * `sender`尝试一次无阻塞的`ACK`报文接收
> * 如果没有收到，继续循环但先不要考虑重传；如果收到了，`ACK`报文的`seq_num`会指明目前`receiver`未收到报文中最小的`seq_num`，请以此调整待发送的报文/已完成发送的报文的集合

##### Sender滑动窗口

在完成基本的传输功能后，你需要结合滑动窗口的机制来调整待发送的报文/已完成发送的报文的集合。窗口大小`window_size`将会作为`sender`/`receiver`的初始化参数。你需要保证当前正在传输，并且没有被`receiver`确认的报文数量，即滑动窗口的上下限之差没有超过`window_size`。所以，当以下情形发生时，你的滑动窗口应该发生一些变化：

> * `sender`已经发出了一些数据报文，但这些数据报文中未被`ACK`报文确认的报文的数量还没有达到滑动窗口的限制。此时，你的滑动窗口的上限应该增加。
> * `sender`的滑动窗口中，在滑动窗口最左侧（也就是窗口中最早发送的报文所在的那一侧）有一个或连续的多个数据报文已经被`ACK`确认。此时，你的滑动窗口的下限应该增加。

**[?]我可以直接把全部的报文都发出去，为什么还要用滑动窗口？**

> 当物理网络的性能所向披靡的时候，这显然是最快最方便的做法。**但现实的物理网络并不像行为确定的软件那般可靠**，如果短时间内突然涌出来大量的报文，网络中的交换机会因为无法缓存而不得不丢弃它们。所以一口气发送全部的报文反而可能会导致大量的丢包进而导致重传，适得其反。为了保证每个报文都被稳稳地送出去，尽量减少重传的次数，这才引入了滑动窗口，来对网络流量进行控制。

##### Sender超时重传

最后，`sender`要添加超时重传的功能，来保证在如下几种网络情况下可以完成可靠传输:

> * `sender`传出/`receiver`传回的报文丢失
> * `ACK`报文的乱序到达
> * 任意数量的任意`ACK`报文多次接收
> * `receiver`传回的报文`checksum`错误

`receiver`对每一个数据报文，会以发回一个`ACK`报文的方式确认收到。为了处理数据报文丢失或者`ACK`报文丢失的情况，你需要设置一个计时器以自动重传未被确认的数据报文。

具体的重传逻辑如下：该计时器在滑动窗口发生变化时重置，当该计时器距离上次重置的时间过去100ms的时候，需要将**当前窗口中的所有数据报文**全部重新发送。

### 第二部分：实现RTP Receiver

#### Receiver实现要求

你应当在`receiver.c`程序中基于给定的`main`函数实现完整的`receiver`功能。启动`receiver`所需的参数会通过命令行参数按照如下顺序给出：接收端需要监听的端口、待接收文件的存放路径、窗口最大尺寸和是否启用优化模式。

``` cpp
// receiver.c
#include "rtp.h"
#include "util.h"

int main(int argc, char **argv) {
    if (argc != 5) {
        LOG_FATAL("Usage: ./receiver [Receiver Port] [File Path] [Window Size] "
                  "[Mode]\n");
    }

    LOG_DEBUG("Receiver: exiting...\n");

    return 0;
}
```

#### Receiver功能说明

`receiver`应该监听指定端口，采用RTP协议，基于GBN算法，通过UDP套接字从接收方接收数据，并以文件的形式存储收到的数据。

##### Receiver对任何收入报文的检查

与`sender`相同，`receiver`需要对收到的报文计算其CRC32的`checksum`，对于`checksum`不对的报文应当直接丢弃。

##### Receiver建立连接和终止连接

`receiver`在启动时需要根据给定参数进行初始化，并按照上述流程建立连接。在收到`sender`传来的`flags`标记了`FIN`的报文时，应该主动结束文件写入，并按照上述流程终止连接。

##### Receiver对数据报文的响应方式（GBN）

对于每一个被确认接收的数据报文，`receiver`需要发送一个`ACK`报文，该报文的`seq_num`为当前期望收到的下一个数据报文的`seq_num`。这个期望收到的数据报文是当前未被`receiver`收到的报文中，`seq_num`最小的报文。

举例来说有如下几种情况(设期望收到的下一个报文`seq_num为N`):

> * 如果当前收到的报文`seq_num > N`或者发生了`checksum`错误: 则说明发生了丢包/乱序/传输错误。应该丢弃该报文，并发送一个`seq_num=N`的`ACK`。这就是**Go-Back-N**的具体体现。
> * 如果当前收到的报文`seq_num等于N`: 发送一个`seq_num=M`的`ACK`，这里`M`为`seq_num`最小的还没有被缓存的报文，并将`M`前所有缓存的报文按序写入文件（包括最新收到的报文）。

最终，正确实现GBN的`receiver`应该可以保证在如下故障发生时，仍然可以完成可靠传输：

> * `sender`传出/`receiver`传回的报文丢失
> * 数据报文的乱序到达
> * 任意数量的任意数据报文多次接收
> * `sender`传出的报文`checksum`错误

##### Receiver的滑动窗口

与`sender`类似，对于那些`seq_num >= N + window_size`或`seq_num < N`的报文会被直接丢弃，以保证`receiver`的滑动窗口大小不超过`window_size`。在如下情况发生时，`receiver`的滑动窗口应该有所变化：

> * `receiver`收到当前期望收到的报文（`seq_num = N`）时，滑动窗口应该向着可接收带有更大`seq_num`报文的方向移动。

**[?]文档没有写Receiver的超时重传，我是不是可以开摆不管了？**

> 这个世界上不存在十全十美的文档，因此你仍然需要考虑隐藏在字面之下的细节。如果`receiver`在数据传输阶段完全没有重传机制（也就是每个数据报文的`ACK`报文最多被传输1次），它是否还可以和符合前述行为的`sender`正常协同工作？我们希望同学们可以思考一下这个问题，**这能让大家对lab2的理解更加深入**。

### 第三部分：优化RTP Sender/Receiver的重传逻辑

#### OPT-Sender/OPT-Receiver实现要求

你应当在`sender.c`和`receiver.c`中添加对优化模式的支持，如果传入的参数opt不是0，则视作优化模式启动。**注意该功能需要兼容之前写的建立连接以及断开连接的代码**，我们的优化模式只修改传输阶段的工作逻辑，建立连接和断开连接的部分不作变化。

#### OPT-Sender/OPT-Receiver功能说明

##### 普通版RTP的性能隐患

在这部分中，我们将对前两部分所写的程序做一些优化。我们之前天衣无缝的RTP还存在什么问题呢？考虑在前面的部分中编写的程序，面对如下窗口大小为3的情况时，将如何工作:

> * `sender`向`receiver`发送了`seq_num`分别为0、1、2的三个数据报文，但`seq_num`为0的数据报文在传输中丢失了。
> * 在这种情况下，`receiver`将返回两个`seq_num`为0的`ACK`报文。这将导致`sender`超时并重传数据报文0、1和2。
> * 然而，`receiver`已经收到过数据报文1和2，只是由于遵循GBN算法而没有缓存它们，所以这两个报文的重传是不必要的。

##### 性能优化：选择重传

为了优化RTP在这种情况下的性能，我们需要保证传输成功的报文不会被重传。因此，你需要相应地修改你的`receiver`和`sender`，将其重传逻辑从**Go-Back-N**修改为**选择重传**。在这个算法中，**`ACK`报文的含义将会发生变化**：其`seq_num`不再表示期望收到的下一个数据报文的`seq_num`，而是表示带有该`seq_num`的数据报文已经被`receiver`收到并缓存。所以你需要做如下改动:

> * 对于`sender`：你需要记录当前滑动窗口内的所有数据报文中，哪些报文收到了对应的**正确的**`ACK`，哪些没有。当计时器达到重传时限时，重置计时器，并只重传那些**没有被`ACK`确认的报文**。其滑动窗口仍然需要满足不会超出尺寸上限的原则，并会随着传输成功自行移动。
> * 对于`receiver`：在收到`seq_num`为`X`的数据报文后，检查**其`checksum`是否正确且`seq_num`是否在滑动窗口内**。如果无误，**缓存**该数据报文，并发回一个`seq_num`同样为`X`的`ACK`报文，以表明带有该`seq_num`的报文已经被成功接收。如果有误，直接丢弃该数据报文并**不作回应**。其滑动窗口仍然需要满足不会超出尺寸上限的原则，能够筛选出并丢弃不在窗口内的传入报文，并会随着传输成功自行移动。注意，在选择重传的逻辑下，你的`receiver`应该支持在某些情形**下一次性写入多个连续的数据报文，并保证写入的数据顺序正确**。

优化后，在之前的例子中，`sender`仍会等待到超时，但仅重传窗口中未被`ACK`确认的数据报文0，减少了流量的浪费。

## 测试你的RTP协议

**[!]基础设施的重要性**

> **lab2的测试涉及随机要素**，和你的程序交互的进程将会随机产出一些传输错误，来检查你的传输逻辑是否能够正确的处理这些错误。因此，每一次测试的过程中，你实现的协议所面对的情形都会有一些区别（例如这次丢了第1000个报文，但是下一次测试却没丢），这种不确定性将会大大提高debug的难度。所以，为这个项目搭建基础设施（即测试工具）将会非常重要。
> 相信大家在过去几年中经常使用printf大法来输出程序的行为，这是很好的测试方法。但是在测试完成之后，过多的调试输出反而会导致程序运行缓慢，严重浪费同学们的时间（和课程组的经费）。因此我们不得不一行一行删掉日志输出，或者考虑用宏来开关程序的输出：

```cpp
#ifdef DEBUG
printf("sth for debugging\n");
#endif
```

> 但是这种一口气占据三行的日志代码实在是太蠢了，会把源代码弄得脏兮兮的。有没有什么办法可以在一键开关日志的前提下，实现printf的功能，并让日志源代码看起来干净又卫生呢？
> 为了鼓励大家积极使用日志输出来辅助调试，助教团队已经在util.h中提供了一些代码来方便大家为RTP协议增加日志功能：

```cpp
// util.h
#ifdef LDEBUG
#define LOG_DEBUG(...)                                                  \
    do {                                                                \
        fprintf(stderr, "\033[40;33m[ DEBUG    ] \033[0m" __VA_ARGS__); \
        fflush(stderr);                                                 \
    } while (0)
#else
#define LOG_DEBUG(...)
#endif
```

> 这个宏的用法和`printf`一致，但可以被**LDEBUG**宏开关其输出。另外，我们的测评程序同样会使用这个宏来进行调试输出。如果你希望对二者进行区分，你可以复制之后自行修改一份宏专供自己的代码使用。如果你不知道如何修改，请STFW或参考同样在util.h中的另外两个类似的宏。

## 测试程序规范说明

TODO：检查测试描述是否正确

### 被传输文件的规范

所有测试文件名长度不超过100个字符，仅包含`a-z`26个字母。

传输的数据大小不超过`100MB`，其字符集合为char类型的任意字符。

### Sender/Receiver的配置规范

`sender`和`receiver`的窗口大小相同，且不超过`512`。

所有测试点均只有`sender`和`receiver`的一对一传输。

### 可能遭遇的错误类型

测试用的标准`sender`会产生以下四类传输故障：

> * 数据报文丢失
> * 数据报文乱序
> * 数据报文重复
> * 数据报文checksum错误

测试用标准`receiver`会产生以下四类传输故障：

> * `ACK`报文丢失
> * `ACK`报文乱序
> * `ACK`报文重复
> * `ACK`报文checksum错误

### 测试点内容

[ ] todo

### 评分标准

每个测试点分数相同，最终通过所有测试点即可在本lab得到满分。

### 项目文件结构

提供的源代码主要包含以下部分：

> * `third_party`文件夹为googletest源代码，不需要修改。
> * `CMakeLists.txt`为一个可用的CMake模板，实现`sender_def.c`, `receiver_def.c`, `rtp.c`后执行`cmake .`以及`make`即可编译全部代码。`rtp.c`不是必须的，你可以根据实际情况选择性使用这些文件，你也可以修改`CMakeList.txt`以满足自己特定的需求。
> * `src`文件夹下为各函数定义的头文件，以及RTP的协议头格式。

### 运行测试

编译全部代码后执行`make test CTEST_OUTPUT_ON_FAILURE=TRUE GTEST_COLOR=TRUE`即可生成本地测试脚本`rtp_test_all`，每个测试点分数相同。

若想测试单独的测试点，可运行如下命令：

```bash
./rtp_test_all --gtest_filter=`测试点名`
```

例如：

```bash
./rtp_test_all --gtest_filter=RTP.RECEIVER_TEST_LOST_DATA
```

如果想直接运行全部测试，请直接运行`./rtp_test_all`

关于每个测试点具体调用的测试文件，请参见test.cpp源码。

## 常见问题

### 为什么助教总是让我上PIAZZA平台提问，是不想回答我的问题吗？

对于一门200人的高年级大课来说，私信解答的效率是**非常糟糕**的，因为在这样的选课人数下，同学们非常容易问出重复的问题。一个需要5分钟才能说清楚的问题，如果有20个同学都私信来问，就要花费100分钟来解答。但如果这个问题在piazza上发布了，只需要5分钟，我们就能让20个同学都解决这个问题。我们希望让同学们上piazza提问并**不是**拒绝和同学们沟通，恰恰相反，这能大大提高我们为同学们解答的效率，**节省同学们的时间**。换言之，学会上piazza提问能**让你的问题更快地被解答**。一个可以参考的提问流程如下：

> * 不要忘记《提问的智慧》，先自己做一些尝试，即便不能解决也可以排除一些可能性
> * 登入piazza，**先搜索**有没有人问过类似的问题
> * 点击New Post，编辑你的问题并发布。**遵循《提问的智慧》传授的方法能让你的问题更快被解答。**
> * piazza应该会自动开启邮件提醒，不要忘记及时回复那些帮助你的人（解答问题的并不一定是老师助教哦）

### 总是强调RTFM/RTFSC/STFW和《提问的智慧》，弄得我都不敢提问了

我们在lab中反复强调这些内容，是为了**引导**大家学习如何**自主解决问题**并且**更高效地提问**。我们并不否认，《提问的智慧》这篇文章的攻击性比较强（然而如果你想品鉴更强的攻击性，可以去阅读《别像弱智一样提问》），但这并不意味着我们想在同学们和教学团队之间建立起“禁止提问”的高墙。恰恰相反，《提问的智慧》提供了许多卓有成效的**自主解决问题的方法**和**高效的提问方式**，它们能帮助你在向我们提问之前快速搞定大部分在lab中遇到的问题。即便你在lab中不幸地遇到了一些不能独立解决的问题，这篇文章教你们的提问方式也能帮助同学们更全面地描述自己的问题，进而更快地得到我们或者其他同学的帮助。不要小看它的作用，因为**不清晰的提问，最终一定会大大浪费你自己的时间**，这肯定是你最不愿意看到的结果。
